# ИДЗ по АВС № 4
## **Описание программы**
  Я сделал многопоточное приложение, использовав модель итеративный параллелизм, так как в задаче есть два садовника, которые должны обойти всё поле, и раелизация данной модели осуществлена через циклы.

  #### *пример цикла:*
  ```
  while (count != height * length) {
        if (arr[0] == arr[2] && arr[1] == arr[3]) {
            pthread_mutex_lock(&mutex);
            if (field[arr[2]][arr[3]] == 0) {
                usleep(500000);
                printf("Второй садовник обработал клетку с координатами { %d; %d}\n", (int)arr[2], (int)arr[3]);
                field[arr[2]][arr[3]] = 1;
            } else {
                printf("Второй садовник пропустил клетку с координатами { %d; %d}\n", (int)arr[2], (int)arr[3]);
            }
            pthread_mutex_unlock(&mutex);
        } else {
            if (field[arr[2]][arr[3]] == 0) {
                usleep(500000);
                printf("Второй садовник обработал клетку с координатами { %d; %d}\n", (int)arr[2], (int)arr[3]);
                field[arr[2]][arr[3]] = 1;
            } else {
                printf("Второй садовник пропустил клетку с координатами { %d; %d}\n", (int)arr[2], (int)arr[3]);
            }
        }
        usleep(500000);
        if (directionUp) {
            if (arr[2] == 0) {
                --arr[3];
                directionUp = false;
            } else {
                --arr[2];
            }
        } else {
            if (arr[2] == height - 1) {
                --arr[3];
                directionUp = true;
            } else {
                ++arr[2];
            }
        }
        ++count;
    }
  ```

  #### *использование регистров в исправленном методе `main`:*
  ```
  push r12	
  push r13
  push rbx							
  ```

  Таким образом вместо определённых участков памяти в стеке были использованы соответствующие регистры:
  ```
  r12d = strcmp(argv[i], "-h")
  r13 = output
  rbx = указатель на начало argv
  ```


## **Функциональность программы**
- ### **ввод данных с клавиатуры**
  Чтобы ввести число x с клавиатуры, нужно в командной строке ввести флаг `-h` и после него ввести десятичное число. Так как при вычисления интеграла степенной ряд сходится при |x| < 1, то при значении больше 1 программа будет выводить бесконечность.
  
  #### *пример:*
  > ./final.exe -h 0.75

  #### *тесты:*

  > ![im1](images/test_of_h.png)

  `a.exe` запускает первоначальную правильную программу, `final.exe` нашу изменённую. Ответы свопадают, значит наша программа работает верно.


- ### **ввод данных с файла и запись результата в файл**
  Чтобы ввести число x с текстового файла, нужно в командной строке ввести флаг `-f` и после него написать название входного файла, затем название выходного файла.
  
  #### *пример:*
  > ./a.exe -f input.txt output.txt

  #### *тесты:*

  > ![im2](images/test_of_f_1.png)

  > ![im3](images/test_of_f_2.png)

  `final.exe` записал в свои выходные файлы такие же ответы, что и `a.exe`

- ### **генерация числа**
  Чтобы сгенерировать число случайным образом, нужно в командной строке ввести флаг `-r`. Число будет меньше 1 по модулю.

  #### *пример:*
  > gcc ./a.exe -r
  #### *тесты:*
  > ![im5](images/test_of_r.png)

  `final.exe` генерирует случайную строку и строчные гласные буквы переводит в заглавные.

## **Производительность программы**
  Так как для вычисления ln(1 - x) с точностью 0.1%, то для этого требуется не так много выполнений команд, и скорость работы программы примерно одинаковая.

## **Оценка**
  По критерием работы выполнена на оценку 9